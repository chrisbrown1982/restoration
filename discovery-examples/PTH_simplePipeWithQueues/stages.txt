- original.c -- pthread version
- pth.1.cpp -- pthread removal
  + We are back to simple pthread_create conversion here as pthread_join takes NULL
    * Note that we should probably remove for loops that only have pthread_joins in them
  + This is broken because the first stage adds more elements to the buffer than it has room for.
- pth.2.cpp -- code repair begins
  + Lifted the pipeline stages into their own function, ready for unfolding.
  + Equivalent to pth.1.cpp
- pth.3.cpp
  + Unfolded definitions of Stage1, Stage2, and Stage3
  + Equivalent to pth.2.cpp
- pth.4.cpp
  + Merged do loops
    * Need to make sure that the variable in the condition is initialised
    * Leave the iterator/assignment/initialisation outside the if statement
    * Weaken the condition in the introduced if-statement (but not the while condition?)
    * Do this for both the second and third loops; what about the first? Surely you have to apply them uniformly?
      > I think we can argue that they're different types of do-loops; the first stage is over a simple integer that has already been initialised, whereas the second and third stages' condition argument(s) haven't been initialised so we have to bring them out of the introduced if-statement.
      > Note also that you can't lift the assignments out of the merged do-loop because we don't know if they commute with the first stage.
      > Note that we need to make sure that the assignments that occur between each of the loops can be moved above the merged loop.
  + This is now equivalent to original.c
- pth.5.cpp -- shaping begins
  + We want to match the reads and writes (to eliminate the queues, effectively)
    * Yes, because 1) the queues are pointless in a sequential case and b) TBB doesn't need them
  + In order to do this, we need to unfold read_from_queue and add_to_queue
  + Labelling (automatic or otherwise) of reads/writes is more interesting than our simple example because here our reads also update the state (i.e. they remove something from the shared state).
    * This likely means that our simple matching approach will not work?



- old.pth.4.cpp
  + Merged do loops (should we convert these to for-loops first?)
  + Equivalent to pth.3.cpp
    * Wait, what?
    * The output Queue keeps going up and the other stages don't seem to be firing.
    * They're not firing because I've wrapped the if statements around the statement that fetches from the queues.
    * Perhaps we should change the do-loops to for-loops first?
      > Either way, we need to know what the iterator is
      > Here, that's read_from_queue
- old.pth.4.alt.cpp
  + Converted do-loops to for-loops
    * We need to know what the iterator is and what the initial value is.
    * Note that in this case we need to weaken the bounds of the for-loops because in a do-loop the body executes before the bound. If you don't weaken it, the loops will not be equivalent. Would need to know how to weaken it; inequalities and numbers aren't too difficult.
    * In this particular case, I don't think it would have a detrimental effect if we *didn't* weaken the bounds, because it would stop at the right time anyway. This is dangerous to apply generally, though.
    * Is the if-condition in stage three wrong, Vladimir?
  + The way I've done this doesn't work though...
    * It either quits the loop immediately or it iterates infinitely.
- old.pth.5.alt.cpp
  + Merged for-loops