- original.c -- pthread version
- pth.1.cpp -- pthread removal
  + We are back to simple pthread_create conversion here as pthread_join takes NULL
    * Note that we should probably remove for loops that only have pthread_joins in them
  + This is broken because the first stage adds more elements to the buffer than it has room for.
- pth.2.cpp -- code repair begins
  + Lifted the pipeline stages into their own function, ready for unfolding.
  + Equivalent to pth.1.cpp
- pth.3.cpp
  + Unfolded definitions of Stage1, Stage2, and Stage3
  + Equivalent to pth.2.cpp
- pth.4.cpp
  + Merged do loops
    * Need to make sure that the variable in the condition is initialised
    * Leave the iterator/assignment/initialisation outside the if statement
    * Weaken the condition in the introduced if-statement (but not the while condition?)
    * Do this for both the second and third loops; what about the first? Surely you have to apply them uniformly?
      > I think we can argue that they're different types of do-loops; the first stage is over a simple integer that has already been initialised, whereas the second and third stages' condition argument(s) haven't been initialised so we have to bring them out of the introduced if-statement.
      > Note also that you can't lift the assignments out of the merged do-loop because we don't know if they commute with the first stage.
      > Note that we need to make sure that the assignments that occur between each of the loops can be moved above the merged loop.
  + This is now equivalent to original.c
- pth.5.cpp -- shaping begins
  + We want to match the reads and writes (to eliminate the queues, effectively)
    * Yes, because 1) the queues are pointless in a sequential case and b) TBB doesn't need them
  + In order to do this, we need to unfold read_from_queue and add_to_queue
  + Labelling (automatic or otherwise) of reads/writes is more interesting than our simple example because here our reads also update the state (i.e. they remove something from the shared state).
    * This likely means that our simple matching approach will not work?
- pth.6.cpp -- Now we match up reads and writes.
  + I can't remember how we did this originally, but by the look of it, we can go down the merged loop in order.
    * What happens in the event that a stage is skipped? Is this a valid pipeline?
  + We end up with three cases:
    1. a read by itself (source)
    2. a write and a read
    3. a write by itself (sink)
  + This still rather assumes that we're grouping together operations that are reads and writes.
    * Perhaps we should group together contiguous examples.
      > In stage one, the three writes are one write.
      > In stage two, we have a read and two writes, followed by three writes.
      > In stage three we have a read and two writes, followed by three 
  + How do we know what is meaningfull updating/reading code and what is just housekeeping?
    * Perhaps we need to group also on the variables we're reading/writing?
    * We need a third category, I think: updating, i.e. where you read and write in the same block
      > Let's assume we don't pair updates: they're self-contained (inherently)
    * We end up with the following cases:
      0. an update (how do we handle those, threading-wise? Need to sort the wheat from the chaff)
        (addTo, nr_elements, readFrom)
      1. a read by itself
        (addTo, capacity, readFrom)
      2. a write and a read
        (elements)
      3. a write by itself (sink)
        (elements)
    * Leave updates (0) as they are for the moment
    * A read by itself (1) can also be left for the moment
    * For a write and a read (2), you replace the RHS of the read with the RHS of the write.
    * For a write by itself (3), we leave it be for the moment
  + Equivalent to original.c
- pth.7.cpp -- localising the variables



- old.pth.4.cpp
  + Merged do loops (should we convert these to for-loops first?)
  + Equivalent to pth.3.cpp
    * Wait, what?
    * The output Queue keeps going up and the other stages don't seem to be firing.
    * They're not firing because I've wrapped the if statements around the statement that fetches from the queues.
    * Perhaps we should change the do-loops to for-loops first?
      > Either way, we need to know what the iterator is
      > Here, that's read_from_queue
- old.pth.4.alt.cpp
  + Converted do-loops to for-loops
    * We need to know what the iterator is and what the initial value is.
    * Note that in this case we need to weaken the bounds of the for-loops because in a do-loop the body executes before the bound. If you don't weaken it, the loops will not be equivalent. Would need to know how to weaken it; inequalities and numbers aren't too difficult.
    * In this particular case, I don't think it would have a detrimental effect if we *didn't* weaken the bounds, because it would stop at the right time anyway. This is dangerous to apply generally, though.
    * Is the if-condition in stage three wrong, Vladimir?
  + The way I've done this doesn't work though...
    * It either quits the loop immediately or it iterates infinitely.
- old.pth.5.alt.cpp
  + Merged for-loops